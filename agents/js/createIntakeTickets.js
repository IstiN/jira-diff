/**
 * Create Intake Tickets Post-Action
 * Reads AI-generated stories.json, creates Epics and Stories in Jira (two-pass),
 * posts an analysis comment, labels the source ticket, and moves it to Done.
 */

const { extractTicketKey } = require('./common/jiraHelpers.js');
const { buildSummary } = require('./common/aiResponseParser.js');
const { ISSUE_TYPES, LABELS, STATUSES } = require('./config.js');

/**
 * Read and parse outputs/stories.json
 * @returns {Array} Array of story/epic entries, or empty array on error
 */
function readStoriesJson() {
    try {
        var raw = file_read('outputs/stories.json');
        if (!raw || raw.trim() === '') {
            console.warn('outputs/stories.json is empty');
            return [];
        }
        var parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) {
            console.warn('outputs/stories.json is not an array');
            return [];
        }
        return parsed;
    } catch (error) {
        console.error('Failed to read/parse outputs/stories.json:', error);
        return [];
    }
}

/**
 * Read outputs/comment.md, with fallback text
 * @returns {string} Comment text
 */
function readCommentFile() {
    try {
        var content = file_read('outputs/comment.md');
        if (content && content.trim() !== '') {
            return content;
        }
    } catch (error) {
        console.warn('Could not read outputs/comment.md:', error);
    }
    return 'h3. *Intake Analysis*\n\n_No analysis comment was generated._';
}

/**
 * Read a description file, falling back to the entry summary
 * @param {string} filePath - Path to the description markdown file
 * @param {string} fallbackSummary - Summary to use if file can't be read
 * @returns {string} Description content
 */
function readDescriptionFile(filePath, fallbackSummary) {
    if (!filePath) {
        return fallbackSummary || '';
    }
    try {
        var content = file_read(filePath);
        if (content && content.trim() !== '') {
            return content;
        }
    } catch (error) {
        console.warn('Could not read description file ' + filePath + ':', error);
    }
    return fallbackSummary || '';
}

/**
 * Create an Epic in Jira
 * @param {Object} entry - Entry from stories.json (no parent)
 * @param {string} projectKey - Jira project key
 * @returns {string|null} Created ticket key or null on failure
 */
function createEpic(entry, projectKey) {
    var summary = buildSummary(entry.summary, 0);
    var description = readDescriptionFile(entry.description, summary);

    try {
        var result = jira_create_ticket_basic({
            project: projectKey,
            issueType: ISSUE_TYPES.EPIC,
            summary: summary,
            description: description
        });
        var key = extractTicketKey(result);
        console.log('Created Epic: ' + (key || '(unknown key)') + ' - ' + summary);
        return key;
    } catch (error) {
        console.error('Failed to create Epic "' + summary + '":', error);
        return null;
    }
}

/**
 * Create a Story in Jira under the given parent
 * @param {Object} entry - Entry from stories.json (has parent)
 * @param {string} resolvedParent - Resolved parent ticket key
 * @param {string} projectKey - Jira project key
 * @returns {string|null} Created ticket key or null on failure
 */
function createStory(entry, resolvedParent, projectKey) {
    var summary = buildSummary(entry.summary, 0);
    var description = readDescriptionFile(entry.description, summary);

    try {
        var result = jira_create_ticket_with_parent({
            project: projectKey,
            issueType: ISSUE_TYPES.STORY,
            summary: summary,
            description: description,
            parentKey: resolvedParent
        });
        var key = extractTicketKey(result);
        console.log('Created Story: ' + (key || '(unknown key)') + ' under ' + resolvedParent + ' - ' + summary);
        return key;
    } catch (error) {
        console.error('Failed to create Story "' + summary + '" under ' + resolvedParent + ':', error);
        return null;
    }
}

/**
 * Build the final comment combining AI analysis + created ticket list
 * @param {Array} results - Array of { type, summary, key, success, error }
 * @param {string} aiComment - AI-generated comment from outputs/comment.md
 * @returns {string} Full comment for Jira
 */
function buildFinalComment(results, aiComment) {
    var comment = aiComment + '\n\n';
    comment += 'h3. *Created Tickets*\n\n';

    var successes = results.filter(function(r) { return r.success; });
    var failures = results.filter(function(r) { return !r.success; });

    if (successes.length === 0 && failures.length === 0) {
        comment += '_No tickets were created (stories.json was empty)._\n';
    } else {
        successes.forEach(function(r) {
            comment += '* [' + r.key + '|https://dmtools.atlassian.net/browse/' + r.key + '] (' + r.type + ') - ' + r.summary + '\n';
        });

        if (failures.length > 0) {
            comment += '\n*Failed to Create:*\n';
            failures.forEach(function(r) {
                comment += '* (' + r.type + ') ' + r.summary + ' - Error: ' + r.error + '\n';
            });
        }

        comment += '\n*Total Created:* ' + successes.length + ' ticket(s)';
    }

    return comment;
}

function action(params) {
    try {
        var ticketKey = params.ticket.key;
        var projectKey = ticketKey.split('-')[0];
        var initiatorId = params.initiator;
        var wipLabel = params.metadata && params.metadata.contextId
            ? params.metadata.contextId + '_wip'
            : null;

        console.log('Processing intake ticket creation for:', ticketKey);

        // 1. Read stories.json
        var stories = readStoriesJson();
        console.log('Found ' + stories.length + ' entries in stories.json');

        var results = [];
        var tempIdMap = {}; // maps "temp-X" -> actual Jira key

        // 2. PASS 1: Create all Epics (entries with no parent or parent=null)
        stories.forEach(function(entry) {
            if (!entry.parent) {
                var key = createEpic(entry, projectKey);
                var summary = buildSummary(entry.summary, 0);
                if (key && entry.tempId) {
                    tempIdMap[entry.tempId] = key;
                    console.log('Mapped tempId ' + entry.tempId + ' -> ' + key);
                }
                results.push({
                    type: 'Epic',
                    summary: summary,
                    key: key,
                    success: !!key,
                    error: key ? null : 'Creation failed (see logs)'
                });
            }
        });

        // 3. PASS 2: Create all Stories (entries with parent set)
        stories.forEach(function(entry) {
            if (entry.parent) {
                var resolvedParent = entry.parent;
                // Resolve temp IDs to actual keys
                if (typeof resolvedParent === 'string' && resolvedParent.indexOf('temp') === 0) {
                    if (tempIdMap[resolvedParent]) {
                        resolvedParent = tempIdMap[resolvedParent];
                    } else {
                        console.warn('Could not resolve tempId "' + entry.parent + '" - skipping story: ' + entry.summary);
                        results.push({
                            type: 'Story',
                            summary: buildSummary(entry.summary, 0),
                            key: null,
                            success: false,
                            error: 'Could not resolve parent tempId "' + entry.parent + '"'
                        });
                        return;
                    }
                }
                var key = createStory(entry, resolvedParent, projectKey);
                var summary = buildSummary(entry.summary, 0);
                results.push({
                    type: 'Story',
                    summary: summary,
                    key: key,
                    success: !!key,
                    error: key ? null : 'Creation failed (see logs)'
                });
            }
        });

        // 4. Read AI comment
        var aiComment = readCommentFile();

        // 5. Post combined comment to source ticket
        try {
            var finalComment = buildFinalComment(results, aiComment);
            jira_post_comment({
                key: ticketKey,
                comment: finalComment
            });
            console.log('Posted intake analysis comment to ' + ticketKey);
        } catch (commentError) {
            console.warn('Failed to post comment to ' + ticketKey + ':', commentError);
        }

        // 6. Add ai_intake label
        try {
            jira_add_label({
                key: ticketKey,
                label: LABELS.AI_INTAKE
            });
        } catch (labelError) {
            console.warn('Failed to add ' + LABELS.AI_INTAKE + ' label:', labelError);
        }

        // 7. Add ai_generated label
        try {
            jira_add_label({
                key: ticketKey,
                label: LABELS.AI_GENERATED
            });
        } catch (labelError) {
            console.warn('Failed to add ' + LABELS.AI_GENERATED + ' label:', labelError);
        }

        // 8. Assign to initiator
        try {
            jira_assign_ticket_to({
                key: ticketKey,
                accountId: initiatorId
            });
            console.log('Assigned ' + ticketKey + ' to initiator');
        } catch (assignError) {
            console.warn('Failed to assign ticket:', assignError);
        }

        // 9. Move to Done
        try {
            jira_move_to_status({
                key: ticketKey,
                statusName: STATUSES.DONE
            });
            console.log('Moved ' + ticketKey + ' to Done');
        } catch (statusError) {
            console.warn('Failed to move ticket to Done:', statusError);
        }

        // 10. Remove WIP label if present
        if (wipLabel) {
            try {
                jira_remove_label({
                    key: ticketKey,
                    label: wipLabel
                });
                console.log('Removed WIP label "' + wipLabel + '" from ' + ticketKey);
            } catch (wipError) {
                console.warn('Failed to remove WIP label:', wipError);
            }
        }

        var successCount = results.filter(function(r) { return r.success; }).length;

        return {
            success: true,
            message: 'Intake complete for ' + ticketKey + ': created ' + successCount + ' ticket(s), moved to Done',
            results: results
        };

    } catch (error) {
        console.error('Error in createIntakeTickets:', error);

        try {
            if (params && params.ticket && params.ticket.key) {
                jira_post_comment({
                    key: params.ticket.key,
                    comment: '*Intake Workflow Error:* ' + error.toString() + '. Please check server logs for details.'
                });
            }
        } catch (commentError) {
            console.error('Failed to post error comment:', commentError);
        }

        return {
            success: false,
            error: error.toString()
        };
    }
}
